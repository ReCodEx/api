<?php

namespace App\Helpers\Swagger;

use App\Helpers\Notifications\ReviewsEmailsSender;
use App\Model\Repository\AssignmentSolutions;
use App\Model\Entity\Group;
use App\Model\Entity\User;
use App\V1Module\Router\MethodRoute;
use Nette\Routing\RouteList;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Doctrine\Common\Annotations\AnnotationReader;
use DateTime;


enum HttpMethods: string {
  case GET = "@GET";
  case POST = "@POST";
  case PUT = "@PUT";
  case DELETE = "@DELETE";
}

/**
 * Builder class that handles .php file creation.
 */
class FileBuilder {
    private $file;
    private $methodEntries;

    public function __construct(
        string $filename
    ) {
        $this->initFile($filename);
        $this->methodEntries = 0;
    }

    private function initFile(string $filename) {
        $this->file = fopen($filename, "w");
        fwrite($this->file, "<?php\n");
        fwrite($this->file, "/// THIS FILE WAS AUTOGENERATED\n");
        fwrite($this->file, "namespace App\V1Module\Presenters;\n");
        fwrite($this->file, "use OpenApi\Annotations as OA;\n");
    }

    private function createInfoAnnotation(string $version, string $title) {
        $head = "@OA\\Info";
        $body = new ParenthesesBuilder();
        $body->addKeyValue("version", $version);
        $body->addKeyValue("title", $title);
        return $head . $body->toString();
    }

    private function writeAnnotationLineWithComments(string $annotationLine) {
        fwrite($this->file, "/**\n");
        fwrite($this->file, "* {$annotationLine}\n");
        fwrite($this->file, "*/\n");
    }

    public function startClass(string $className, string $version, string $title) {
        $this->writeAnnotationLineWithComments($this->createInfoAnnotation($version, $title));
        fwrite($this->file, "class {$className} {\n");
    }

    public function endClass(){
        fwrite($this->file, "}\n");
        fflush($this->file);
        fclose($this->file);
    }

    public function addAnnotatedMethod(string $methodName, string $annotationLine) {
        $this->writeAnnotationLineWithComments($annotationLine);
        fwrite($this->file, "public function {$methodName}{$this->methodEntries}() {}\n");
        $this->methodEntries++;
    }
}

/**
 * Builder class that can create strings of the schema: '(key1="value1", key2="value2", standalone1, standalone2, ...)'
 */
class ParenthesesBuilder {
    private array $tokens;

    public function __construct() {
        $this->tokens = [];
    }

    public function addKeyValue(string $key, mixed $value): ParenthesesBuilder {
        $valueString = strval($value);
        # strings need to be wrapped in quotes
        if (is_string($value))
            $valueString = "\"{$value}\"";
        # convert bools to strings
        else if (is_bool($value))
            $valueString = ($value ? "true" : "false");

        $assignment = "{$key}={$valueString}";
        return $this->addValue($assignment);
    }

    public function addValue(string $value): ParenthesesBuilder {
        $this->tokens[] = $value;
        return $this;
    }

    public function toString(): string {
        return '(' . implode(',', $this->tokens) . ')';
    }
}

class AnnotationData {
  public HttpMethods $httpMethod;
  
  public array $pathParams;
  public array $queryParams;
  public array $bodyParams;

  public function __construct(
      HttpMethods $httpMethod,
      array $pathParams,
      array $queryParams,
      array $bodyParams
  ) {
      $this->httpMethod = $httpMethod;
      $this->pathParams = $pathParams;
      $this->queryParams = $queryParams;
      $this->bodyParams = $bodyParams;
  }

  private function getHttpMethodAnnotation(): string {
      # sample: converts '@PUT' to 'Put'
      $httpMethodString = ucfirst(strtolower(substr($this->httpMethod->value, 1)));
      return "@OA\\" . $httpMethodString;
  }

  private function getBodyAnnotation(): string|null {
      if (count($this->bodyParams) === 0) {
          return null;
      }

      ///TODO: only supports JSON
      $head = '@OA\RequestBody(@OA\MediaType(mediaType="application/json",@OA\Schema';
      $body = new ParenthesesBuilder();

      foreach ($this->bodyParams as $bodyParam) {
          $body->addValue($bodyParam->toPropertyAnnotation());
      }

      return $head . $body->toString() . "))";
  }

  /**
   * Converts the extracted annotation data to a string parsable by the Swagger-PHP library.
   * @param string $route The route of the handler this set of data represents.
   * @return string Returns the transpiled annotations on a single line.
   */
  public function toSwaggerAnnotations(string $route) {
      $httpMethodAnnotation = $this->getHttpMethodAnnotation();
      $body = new ParenthesesBuilder();
      $body->addKeyValue("path", $route);

      foreach ($this->pathParams as $pathParam) {
          $body->addValue($pathParam->toParameterAnnotation());
      }
      foreach ($this->queryParams as $queryParam) {
          $body->addValue($queryParam->toParameterAnnotation());
      }

      $jsonProperties = $this->getBodyAnnotation();
      if ($jsonProperties !== null)
          $body->addValue($jsonProperties);

      ///TODO: placeholder
      $body->addValue('@OA\Response(response="200",description="The data")');
      return $httpMethodAnnotation . $body->toString();
  }
}


/**
 * Contains data of a single annotation parameter.
 */
class AnnotationParameterData {
  public string|null $dataType;
  public string $name;
  public string|null $description;
  public string $location;

  private static $nullableSuffix = '|null';
  private static $typeMap = [
      'bool' => 'boolean',
      'boolean' => 'boolean',
      'array' => 'array',
      'int' => 'integer',
      'integer' => 'integer',
      'float' => 'number',
      'number' => 'number',
      'numeric' => 'number',
      'numericint' => 'integer',
      'timestamp' => 'integer',
      'string' => 'string',
      'unicode' => 'string',
      'email' => 'string',
      'url' => 'string',
      'uri' => 'string',
      'pattern' => null,
      'alnum' => 'string',
      'alpha' => 'string',
      'digit' => 'string',
      'lower' => 'string',
      'upper' => 'string',
  ];

  public function __construct(
      string|null $dataType,
      string $name,
      string|null $description,
      string $location
  ) {
      $this->dataType = $dataType;
      $this->name = $name;
      $this->description = $description;
      $this->location = $location;
  }

  private function isDatatypeNullable(): bool {
      # if the dataType is not specified (it is null), it means that the annotation is not
      # complete and defaults to a non nullable string
      if ($this->dataType === null)
          return false;

      # assumes that the typename ends with '|null'
      if (str_ends_with($this->dataType, self::$nullableSuffix))
          return true;

      return false;
  }

  private function getSwaggerType(): string {
      # if the type is not specified, default to a string
      $type = 'string';
      $typename = $this->dataType;
      if ($typename !== null) {
          if ($this->isDatatypeNullable())
              $typename = substr($typename,0,-strlen(self::$nullableSuffix));
  
          if (self::$typeMap[$typename] === null) 
              ///TODO: return the commented exception
              return 'string';
              //throw new \InvalidArgumentException("Error in getSwaggerType: Unknown typename: {$typename}");
          
          $type = self::$typeMap[$typename];
      }
      return $type;
  }

  private function generateSchemaAnnotation(): string {
      $head = "@OA\\Schema";
      $body = new ParenthesesBuilder();

      $body->addKeyValue("type", $this->getSwaggerType());
      return $head . $body->toString();
  }

  /**
   * Converts the object to a @OA\Parameter(...) annotation string
   */
  public function toParameterAnnotation(): string {
      $head = "@OA\\Parameter";
      $body = new ParenthesesBuilder();
      
      $body->addKeyValue("name", $this->name);
      $body->addKeyValue("in", $this->location);
      $body->addKeyValue("required", !$this->isDatatypeNullable());
      if ($this->description !== null)
          $body->addKeyValue("description", $this->description);

      $body->addValue($this->generateSchemaAnnotation());

      return $head . $body->toString();
  }

  public function toPropertyAnnotation(): string {
      $head = "@OA\\Property";
      $body = new ParenthesesBuilder();

      ///TODO: handle nullability
      $body->addKeyValue("property", $this->name);
      $body->addKeyValue("type", $this->getSwaggerType());
      return $head . $body->toString();
  }
}


/**
 * Parser that can parse the annotations of existing recodex endpoints
 */
class AnnotationHelper {
    private static function getMethod(string $className, string $methodName): \ReflectionMethod {
        $class = new \ReflectionClass($className);
        return $class->getMethod($methodName);
    }

    private static function extractAnnotationHttpMethod(array $annotations): HttpMethods|null {
        # get string values of backed enumeration
        $cases = HttpMethods::cases();
        $methods = [];
        foreach ($cases as $case) {
            $methods[] = $case->value;
        }

        # check if the annotations have a http method
        foreach ($methods as $method) {
            if (in_array($method, $annotations)) {
                return HttpMethods::from($method);
            }
        }

        return null;
    }

    private static function extractStandardAnnotationParams(array $annotations, string $route): array {
        $routeParams = self::getRoutePathParamNames($route);

        $params = [];
        foreach ($annotations as $annotation) {
            # assumed that all query parameters have a @param annotation
            if (str_starts_with($annotation, "@param")) {
                # sample: @param string $id Identifier of the user
                $tokens = explode(" ", $annotation);
                $type = $tokens[1];
                # assumed that all names start with $
                $name = substr($tokens[2], 1);
                $description = implode(" ", array_slice($tokens,3));

                # figure out where the parameter is located
                $location = 'query';
                if (in_array($name, $routeParams))
                    $location = 'path';

                $descriptor = new AnnotationParameterData($type, $name, $description, $location);
                $params[] = $descriptor;
            }
        }
        return $params;
    }

    private static function extractBodyParams(array $expressions): array {
        $dict = [];
        #sample: [ 'name="uiData"', 'validation="array|null"' ]
        foreach ($expressions as $expression) {
            $tokens = explode('="', $expression);
            $name = $tokens[0];
            # remove the '"' at the end
            $value = substr($tokens[1], 0, -1);
            $dict[$name] = $value;
        }
        return $dict;
    }

    private static function extractNetteAnnotationParams(array $annotations): array {
        $bodyParams = [];
        $prefix = "@Param";
        foreach ($annotations as $annotation) {
            # assumed that all body parameters have a @Param annotation
            if (str_starts_with($annotation, $prefix)) {
                # sample: @Param(type="post", name="uiData", validation="array|null", description="Structured user-specific UI data")
                # remove '@Param(' from the start and ')' from the end
                $body = substr($annotation, strlen($prefix) + 1, -1);
                $tokens = explode(", ", $body);
                $values = self::extractBodyParams($tokens);
                $descriptor = new AnnotationParameterData($values["validation"],
                    $values["name"], $values["description"],  $values["type"]);
                $bodyParams[] = $descriptor;
            }
        }
        return $bodyParams;
    }

    private static function getMethodAnnotations(string $className, string $methodName): array {
        $annotations = self::getMethod($className, $methodName)->getDocComment();
        $lines = preg_split("/\r\n|\n|\r/", $annotations);

        # trims whitespace and asterisks
        # assumes that asterisks are not used in some meaningful way at the beginning and end of a line
        foreach ($lines as &$line) {
            $line = trim($line);
            $line = trim($line, "*");
            $line = trim($line);
        }

        # removes the first and last line
        # assumes that the first line is '/**' and the last line '*/' (or '/' after trimming) 
        $lines = array_slice($lines, 1, -1);

        $merged = [];
        for ($i = 0; $i < count($lines); $i++) {
            $line = $lines[$i];

            # skip lines not starting with '@'
            if ($line[0] !== "@")
                continue;

            # merge lines not starting with '@' with their parent lines starting with '@'
            while ($i + 1 < count($lines) && $lines[$i + 1][0] !== "@") {
                $line .= " " . $lines[$i + 1];
                $i++;
            }

            $merged[] = $line;
        }

        return $merged;
    }

    private static function getRoutePathParamNames(string $route): array {
        # sample: from '/users/{id}/{name}' generates ['id', 'name']
        preg_match_all('/\{([A-Za-z0-9 ]+?)\}/', $route, $out);
        return $out[1];
    }

    public static function extractAnnotationData(string $className, string $methodName, string $route): AnnotationData {
        $methodAnnotations = self::getMethodAnnotations($className, $methodName);

        $httpMethod = self::extractAnnotationHttpMethod($methodAnnotations);
        $standardAnnotationParams = self::extractStandardAnnotationParams($methodAnnotations, $route);
        $netteAnnotationParams = self::extractNetteAnnotationParams($methodAnnotations);
        $params = array_merge($standardAnnotationParams, $netteAnnotationParams);

        $pathParams = [];
        $queryParams = [];
        $bodyParams = [];

        foreach ($params as $param) {
            if ($param->location === 'path')
                $pathParams[] = $param;
            else if ($param->location === 'query')
                $queryParams[] = $param;
            else if ($param->location === 'post')
                $bodyParams[] = $param;
            else
                throw new \Exception("Error in extractAnnotationData: Unknown param location: {$param->location}");
        }


        $data = new AnnotationData($httpMethod, $pathParams, $queryParams, $bodyParams);
        return $data;
    }

    private static function filterAnnotations(array $annotations, string $type) {
        $rows = [];
        foreach ($annotations as $annotation) {
            if (str_starts_with($annotation, $type)) {
                $rows[] = $annotation;
            }
        }
        return $rows;
    } 

    private static function extractFormatData(array $annotations): array {
        $formats = [];
        $filtered = self::filterAnnotations($annotations, "@format_def");
        foreach ($filtered as $annotation) {
            # sample: @format user_info { "name":"format:name", "points":"format:int", "comments":"format:string[]" }
            $tokens = explode(" ", $annotation);
            $name = $tokens[1];
            
            $jsonStart = strpos($annotation, "{");
            $json = substr($annotation, $jsonStart);
            $format = json_decode($json);

            $formats[$name] = $format;
        }
        return $formats;
    }

    private static function extractMethodFormats(string $className, string $methodName): array {
        $annotations = self::getMethodAnnotations($className, $methodName);
        return self::extractFormatData($annotations);
    }

    public static function extractClassFormats(string $className): array {
        $methods = get_class_methods($className);
        $formatDicts = [];
        foreach ($methods as $method) {
            $formatDicts[] = self::extractMethodFormats($className, $method);
        }

        return array_merge(...$formatDicts);
    }

    public static function extractMethodCheckedParams(string $className, string $methodName): array {
        $annotations = self::getMethodAnnotations($className, $methodName);
        $filtered = self::filterAnnotations($annotations, "@checked_param");
        
        $paramMap = [];
        foreach ($filtered as $annotation) {
            // sample: @checked_param format:group group
            $tokens = explode(" ", $annotation);
            $format = $tokens[1];
            $name = $tokens[2];
            $paramMap[$name] = $format;
        }

        return $paramMap;
    }

    public static function extractClassFormat(string $className) {
        $class = new \ReflectionClass($className);
        $fields = get_class_vars($className);
        foreach ($fields as $fieldName=>$value) {
            $field = $class->getProperty($fieldName);
            $fieldType = $field->getType()->getName();
            var_dump($fieldType);
        }
    }
}
