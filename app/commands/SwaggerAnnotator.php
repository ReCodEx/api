<?php

namespace App\Console;

use App\Helpers\Swagger\FileBuilder;
use App\Helpers\Swagger\AnnotationHelper;
use App\V1Module\Router\MethodRoute;
use Nette\Routing\RouteList;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class SwaggerAnnotator extends Command
{
    protected static $defaultName = 'swagger:annotate';
    private static $presenterNamespace = 'App\V1Module\Presenters\\';
    private static $autogeneratedAnnotationFilePath = 'app/V1Module/presenters/_autogenerated_annotations_temp.php';

    protected function configure(): void
    {
        $this->setName(self::$defaultName)->setDescription(
            'Annotate all methods with Swagger PHP annotations.'
        );
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        # create a temporary file containing transpiled annotations usable by the external library (Swagger-PHP)
        $fileBuilder = new FileBuilder(self::$autogeneratedAnnotationFilePath);
        $fileBuilder->startClass('__Autogenerated_Annotation_Controller__', '1.0', 'ReCodEx API');

        # get all routes of the api
        $routes = $this->getRoutes();
        foreach ($routes as $routeObj) {
            # extract class and method names of the endpoint
            $metadata = $this->extractMetadata($routeObj);
            $route = $this->extractRoute($routeObj);
            $className = self::$presenterNamespace . $metadata['class'];

            # extract data from the existing annotations
            $annotationData = AnnotationHelper::extractAnnotationData($className, $metadata['method'], $route);

            # add an empty method to the file with the transpiled annotations
            $fileBuilder->addAnnotatedMethod($metadata['method'], $annotationData->toSwaggerAnnotations($route));
        }
        $fileBuilder->endClass();

        return Command::SUCCESS;
    }

    /**
     * Finds all route objects of the API
     * @return array Returns an array of all found route objects.
     */
    function getRoutes(): array {
        $router = \App\V1Module\RouterFactory::createRouter();
        
        # find all route object using a queue
        $queue = [$router];
        $routes = [];
        while (count($queue) != 0) {
            $cursor = array_shift($queue);

            if ($cursor instanceof RouteList) {
                foreach ($cursor->getRouters() as $item) {
                    # lists contain routes or nested lists
                    if ($item instanceof RouteList) {
                        array_push($queue, $item);
                    }
                    else {
                        # the first route is special and holds no useful information for annotation
                        if (get_parent_class($item) !== MethodRoute::class)
                            continue;

                        $routes[] = $this->getPropertyValue($item, "route");
                    }
                }
            }
        }

        return $routes;
    }

    /**
     * Extracts the route string from a route object. Replaces '<..>' in the route with '{...}'.
     * @param mixed $routeObj
     */
    private function extractRoute($routeObj): string {
        $mask = self::getPropertyValue($routeObj, "mask");

        # sample: replaces '/users/<id>' with '/users/{id}'
        $mask = str_replace(["<", ">"], ["{", "}"], $mask);
        return "/" . $mask;
    }

    /**
     * Extracts the class and method names of the endpoint handler.
     * @param mixed $routeObj The route object representing the endpoint.
     * @return string[] Returns a dictionary [ "class" => ..., "method" => ...]
     */
    private function extractMetadata($routeObj) {
        $metadata = self::getPropertyValue($routeObj, "metadata");
        $presenter = $metadata["presenter"]["value"];
        $action = $metadata["action"]["value"];

        # if the name is empty, the method will be called 'actionDefault'
        if ($action === null)
            $action = "default";

        return [
            "class" => $presenter . "Presenter",
            "method" => "action" . ucfirst($action),
        ];
    }

    /**
     * Helper function that can extract a property value from an arbitrary object where
     * the property can be private.
     * @param mixed $object The object to extract from.
     * @param string $propertyName The name of the property.
     * @return mixed Returns the value of the property.
     */
    private static function getPropertyValue($object, string $propertyName): mixed
    {
        $class = new \ReflectionClass($object);

        do {
            try {
                $property = $class->getProperty($propertyName);
            } catch (\ReflectionException $exception) {
                $class = $class->getParentClass();
                $property = null;
            }
        } while ($property === null && $class !== null);

        $property->setAccessible(true);
        return $property->getValue($object);
    }
}
